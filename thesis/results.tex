\chapter{Results}
\label{sec:results}
\section{Stakeholders and Requirements}
To ensure that the interactive poster would address the actual needs of its intended audience, the first step in the implementation process was to identify the relevant stakeholders and elicit concrete requirements. This process provided the foundation for the design decisions described in the subsequent sections.

\subsection{Identify stakeholders}
%Present who the stakeholders are and why they matter. For example:
%The professor and research group (owners/beneficiaries of the poster).
%External researchers (intended users).
%Possibly technical staff or students (who may need to maintain or update the system).
%You don’t need to make this exhaustive, but it helps to show that you considered different perspectives.


The stakeholders in this project were defined as all individuals or groups with a direct interest in the functionality, presentation, or long-term use of the poster. As such, the following groups were identified:
\begin{itemize}
	\item The head of the COLAPS research group, Irene-Angelica Chounta, who initiated the project and acted as the primary source of requirements regarding content and functionality.
	\item The other members of the COLAPS research group, whose publications and research topics constitute the content of the poster and who have a stake in how their work is represented.
	\item End-users such as external researchers or students, who are expected to interact with the poster and whose needs for clarity, usability, and engagement shaped the design choices.
\end{itemize}

\subsection{Elicitation Method}
%Describe the elicitation method
%Explain that you prepared guiding questions and conducted an interview with your professor to clarify the main goals and constraints of the system. Mention why this method was appropriate (the professor has the clearest vision of how the poster should represent the group and what message it should convey).

To clarify the needs and constraints of the identified stakeholders, I prepared a set of guiding questions and conducted an interview with the supervising professor, who both initiated the project and represents its primary beneficiary. The questions were structured around themes such as physical constraints, intended goals and audience, content and structure, interaction design, accessibility, maintenance, and success criteria. At this stage, the interview was conducted exclusively with the supervising professor, as she holds the clearest vision of how the poster should represent the research group and how it should be used in practice.

\subsection{Key Requirements}
%Instead of dumping a raw list, structure them into categories:
%Functional requirements (e.g., allow users to browse publications by research category, simple interaction).
%Non-functional requirements (e.g., playful/engaging design, robustness, ease of maintenance).
%Constraints (e.g., available budget, poster size, materials).

From this elicitation process, a set of functional and non-functional requirements emerged, which served as the foundation for subsequent design and implementation decisions.\\

The system shall...
\subsubsection{Functional Requirements}
\begin{itemize}
	\item ... allow users to browse a wide range of content produced by the research group, including publications, seminars, lectures, projects, and thesis topics. 
	\item ... provide a simple and straightforward interaction design. 
	\item ... allow users to manually search for specific content. 
	\item ... support the replacement and editing of data, even if such updates are expected to be infrequent. 
	\item ... consider audio narration as an accessibility feature. 
	\item ... support the scanning of QR codes and NFC tags (e.g., from business cards) for integration into a digital guestbook. 
	\item ... allow the user to take a picture of themselves for the guestbook.
\end{itemize}

\subsubsection{Non-Functional Requirements}
\begin{itemize}
	\item ... be lightweight yet sturdy, ensuring portability by no more than two people. 
	\item ... feature a playful and engaging design that encourages exploration and interaction. 
\end{itemize}

\subsubsection{Constraints}
\begin{itemize}
	\item ... have a maximum size between A1 and A0 format. 
	\item ... be developed within a reasonable budget. 
\end{itemize}


\section{Initial Proof-of-Concept}
%Outlining the initial design process, the thoughts that went into certain choices as well as our meeting where i presented this to you. Would include the design document with explanations.

The initial proof-of-concept phase focused on transforming early design ideas into tangible prototypes, with particular emphasis on the ‘lucky wheel’ metaphor suggested during stakeholder discussions. This metaphor was selected as it provided a recognizable and intuitive interaction model, reducing the need for extensive instruction and encouraging playful engagement.

To quickly visualize the idea and make it into something tangible, a rough paper sketch was made, illustrating the key design points: A spinning wheel to select categories, a screen to browse the content for each category, and a keyboard for user inputs. Additionally, Camera placement for the QR-Code and Guestbook image was also illustrated. \\

Two alternative input devices were considered: an oversized trackball, intended to emphasize playfulness and accessibility, and a retro joystick, valued for its simplicity and iconic status. While the trackball offered unique interaction qualities, it would have required custom development. The joystick, by contrast, was commercially available, familiar to users, and limited in input complexity, making it the more practical choice. Ultimately, the Atari joystick was selected for its minimal design and robustness against both accidental and intentional misuse.\\

Comparing those two ideas, the joystick was ultimately decided to be the better choice. Joysticks were an already established platform/hardware, that could readily be bought at a reasonable price, while the trackball solution would've required extensive development from myself, which would put extra strain on my ability to complete this project in time. They're well known, and it's intuitive nature makes the system more inviting.
Specifically, the Atari joystick was chosen as the input device, due to it originally only having one button and the joystick, thereby minimizing both accidental and intentional misuse.\\ 
\textbf{Provide image of sketch}

A WebApp was created based on the paper sketch to serve as a mockup and simulation for the interaction, as a way to "experience" the idea rather than seeing it just as a flat sketch. The original sketch already considered to use LED signs, which were designed in this step with the help of OpenAI's ChatGPT image generation.\\
\textbf{Provide image of webapp}

The accompanying design document detailed each feature and design choice, while also proposing alternative implementation paths, such as material options for the wheel and housing. By sketching out the workflow of the system at this stage, potential oversights could be identified early, ensuring alignment between interaction concept and technical feasibility.\\
\textbf{provide design document}

The Web App was subsequently presented to the professor, who offered additional feedback and requirements. 
In summary, the proof-of-concept validated the core interaction model of a spinning wheel controlled via joystick, confirmed its feasibility for playful yet robust user engagement, and highlighted specific areas (such as the guestbook feature) requiring refinement. This provided a clear foundation for subsequent CAD modeling and early prototyping.\\

\section{CAD and Materials}
Small section on the creation of the CAD model and material choices/tests
 
\section{Early Prototyping}
%Even before our meeting, when the design i wanted to go for was finalized, i made a small 3d printed prototype to test the sensor and get a hardware proof-of-concept (i actually based the CAD design of the large poster on this one). I'd rather put this here for consistency. It'll probably be a small section but there are actually some problems i faced that i would like to outline here (particularly magnet orientation with the sensor). I later also tried to continue using this prototype before i got the hardware but it proved impossible to use the small SPI screen with the frontend framework i chose simply because i couldn't get the display driver to load correctly and had to write image as bytes manually to the display buffer. Could be interesting to mention too.

\textbf{TODO: Add images for: 3D Printed Prototype fully assembled, CAD Model(?), magnet pole orientation, skewed image on display}\\\\

	A small-scale prototype was developed, drawing upon the CAD and the design specifications previously outlined. The objective of this prototype was not to serve as a functional miniature version of the final poster; rather, it was employed as a platform to validate the feasibility of using magnetic sensors for reliable input capture and to provide a tangible demonstration platform to communicate the concept and design to stakeholders.
	
	\subsection{Design Rationale}
	3D printing was selected as the manufacturing process due to its low cost and ability to rapidly produce customized parts with minimal waste.
	The selection of magnetic sensors/encoders over other technologies, such as rotary encoders, was driven by several factors. These sensors were chosen due to their small form factor, cost-effectiveness, and resistance to mechanical and electrical degradation over time, particularly in prolonged use scenarios. In this particular instance, the utilization of an MT6701 would have been the optimal selection. This is due to the fact that the computations necessary to convert the magnetic field into angular degrees had already been incorporated into the chip's architecture. However, given the unavailability of breakout boards during the developmental stage, an alternative solution was necessary. For this purpose, the TLV493D was selected, as it was readily available on breakout boards, inexpensive, and supported by existing Python libraries. Unlike the MT6701 however, the TLV493D outputs only raw three-axis magnetic field values, requiring additional software computation to derive angular positions.
	
	\subsection{Mechanical Integration}
	The TLV493D magnetic sensor was mounted on a breakout board (black PCB in the render) and integrated into the 3D-printed housing using a set of raised standoffs, with M2 socket head cap screws screwing directly into the plastic. The standoffs ensured both mechanical stability and correct orientation of the sensor relative to the rotating magnet. The circular plug, which was connected to the spinning wheel on the other side, served as the magnet holder. This allowed the sensor to be placed at a fixed distance above the plane of rotation. This configuration guaranteed that the sensor's sensitive area was continuously aligned with the movement trajectory of the magnet, thereby facilitating the reliable capture of angular displacement data. The magnet itself was positioned in parallel alignment to the sensor.\\
	
	\subsection{Electrical Integration}
	The breakout board simplified wiring by providing pre-routed connections and mounting holes. This modularity allowed easy replacement if the sensor failed or the design was modified. Electrically, the TLV493D was connected to the Raspberry Pi via I²C, using pins 3 and 5 for communication and pins 1 (3.3 V) and 9 (ground) for power.
	
	\subsection{Software Integration}
	The initialization of the sensor was largely uncomplicated, primarily due to the presence of an usage example in the library documentation. However, the conversion of the sensor data to degrees and/or radians necessitated the calculation of the arc tangent for the y/x values from the sensor output, followed by the modulo operation with 360 to obtain values ranging from 0 to 360 instead of -180 to 180. The function responsible for reading and calculating the sensor data was delegated to a separate thread, enabling its execution in parallel with the application's other components. 
	
	During the testing phase of the implementation, it was noted that there was minimal change in the values reported by the sensor. These findings were independent of the proximity of the magnet to the sensor, as well as the velocity with which the magnet was rotated. A thorough investigation into the matter revealed that the magnet in question did not possess a magnetic field with the poles divided into two equal segments along the central axis (resulting in each pole representing half of the circular shape). Instead, the poles were positioned on the two opposing large faces of the magnet. Consequently, the magnetic field remained virtually unchanged, with only the pole rotating along its own axis on top of the sensor. Subsequent to orienting the magnet in a perpendicular position relative to the sensor, quantifiable values were obtained, and the calculations were confirmed to be operational.
	
	%Later analysis revealed that the sensor output was found to be quite noisy, thus necessitating the implementation of filtering and/or smoothing techniques to mitigate the impact of noise. The selection of a moving average algorithm was predicated on its simplicity in terms of implementation, its resilience to outliers, and its capacity to provide substantial smoothing. However, the selection and testing of the number of values utilized for the moving average required careful consideration, as an excessive number of values could introduce excess latency to the sensor output, while an insufficient number might not adequately reduce noise. Eventually, the moving average comprised eight values, thereby offering acceptable latency and adequate noise stability.
	The sensor output, however, was noisy. To address this, a moving average filter was implemented. Eight samples per window were found to offer a good compromise between latency and stability, smoothing out spurious fluctuations while maintaining responsiveness.
	
	\subsection{Display Integration and Limitations}
	The incorporation of a display was imperative for the subsequent visualization of the magnets' position in this prototype. The selection of a generic 1.8-inch ST7735 SPI TFT display was made on the basis of its wide availability, diminutive size, and reasonably high resolution for its size. An external Python library had already been developed for this display, which was also one of the primary concerns with this prototype. The display was wired to the Raspberry Pi via standard SPI pins (MOSI, SCLK, CE0) and GPIO pins 24 and 25 for reset and data control.
	The process of displaying images on the display interface was found to be somewhat challenging, though not overly intricate. The library documentation provided an ample array of examples for reference. However, it was not specified that the width and height values could not be interchanged to "simulate" a 90-degree rotation. In order to accomplish this, it is necessary to employ the rotation parameter.
	
	The initial interface presented on the display was developed through the implementation of the Python Imaging Library (PIL). This software continuously generated and transmitted images to the display interface. The image in question consists of a green circle accompanied by a red line, which collectively serve to visualize a compass. Above the image, there is red text displaying the values of both degrees and radians, which are calculated from the sensor output. This was initially useful for visualization and evolved into early versions of the configuration tool as a console application, which was used for recording the angles for each slice.
	
	However, the eventual introduction of a front-end library to power the main application rendered the continued use of the SPI screen increasingly impractical. While the process of streaming single images (even when updated continuously) using the PIL module functioned adequately, there was no sufficient method for streaming Kivy applications without utilizing a display driver and employing the SPI screen as the primary interface. A preliminary investigation was conducted into the potential of employing PIL to capture a screenshot from a Kivy application and transmit it to the display. However, this endeavor was promptly discontinued due to the substantial technical complexity and throughput bottlenecks encountered. Despite the availability of publicly accessible display drivers for ST7735 SPI screens, it was observed that none of these drivers appeared to be compatible with the display utilized in the prototype. The technical intricacy and unpredictability of the endeavor, as well as the potential unavailability of viable outcomes, were not deemed justifiable at this stage of development. Consequently, the SPI screen was regarded as an unstable technological trajectory, leading to its eventual abandonment in the pursuit of a more viable interface.
	
	\subsection{Key Findings}
	This prototyping stage yielded two important outcomes. First, it validated the feasibility of using magnetic sensors for input capture, provided the magnet is oriented correctly and filtering is applied to stabilize noisy data. Second, it eliminated SPI-based displays as a viable option for further prototypes, thereby clarifying hardware requirements for subsequent prototyping.


\section{GUI Design and Creation}
I made \textit{some} Layout drawings for the tools and the application. While those were based on nothing but what i thought would make sense and be usable, might be interesting to include them here while explaining why i did what i did.
Also would include a short paragraph on the frontend framework choice as this one wasn't as straightforward.

\section{Logic Implementation}
Here i'd put \textbf{everthing} i did before refactoring the codebase. This includes everything from the documentation until half of 12.8., like:
\begin{itemize}
	\item Initial Database design
	\item Making the prototype configuration tool on the 3D Prototype with all it's logic 
	\item Later moving it to Kivy (with the problems that came with that)
	\item Creation of the first Application Window and it's expansions
	\item Implementation of the Content Manager tool
	\item Database Redesign (and outlining the risk of SQL Injections which was later fixed)
\end{itemize}

While this list is somewhat chronological, i'm not sure if it makes sense to keep it that way. While during this time, i was mostly focused on finishing one program before starting another, i'm sure there was \textit{some} jumping around, which would make more sense to just keep in its "subcategory" (like Content Manager tool implementation).

\section{Refactoring}

This might be the most interesting section as the learning curve of application development really took it's toll on the program up until this point and things became quite the spaghetti code, which was just unmaintainable and impossible to work with at this point, even for me as the creator.

I'd outline what the issue was, give some explanations on why this was happening and propose the plan i drafted up (and implemented) to mitigate this.

Some POI would be the management layers for topics and categories, the expansion of the database wrapper, and object management in code.

Obviously this all caused some issues after implementation with things i couldn't test at the time, but they were rather minor, so if i include them, i'd probably do it briefly.

Here i also fixed the SQL Injections.

\section{Expanding Capabilities}

This would include...

\begin{itemize}
	\item the implementation of the searchbar
	\item naming categories in the configuration tool
	\item expanding the configuration tool with the ability to rename recorded categories
	\item expanding the category management layer with the necessary functions to facilitate the above and then some (namely creation and deletion)
\end{itemize}

These, too would include thoughts behind certain decisions and problems that were encountered and are worth mentioning (if any).

\section{HID Integration}

Implementing the Joystick controls was also pretty interesting, as it required some reverse engineering (if you could call that) of the communication with the library i chose.
There was also some special design choices i made that i'd like to outline (e.g. using ENUMs to assign inputs).
There's also one problem that i'd like to explain because it also led to an unusual but necessary choice in behavior.\\\\\\\\


As you can tell, there might be things missing. Namely the NFC reader, LEDS, Feedback mechanism and Multimedia support.
This is obviously dependent on whether or not there will be another (albeit short) phase of development, where i might be able to finish one of these features. Which is also dependent on how much of the exposé i can reuse, as rewriting this in it's entirety would take up all the time i have left for this thesis.

I have written a paragraph about this in my documentation, which i would later include in the limitations section.