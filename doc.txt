25.7.
To make use of the extensive capabilities of the pi 5, the config tool will be moved to a kivy based UI. This was also done in order to remove any complications that came with drawing to the screen directly instead of using a GUI framework, as well as streamlining the entire software to be more consistent.
The first prototype was still based on the PIL Image being drawn and shown in a Kivy GUI, but this approach was quickly abandoned due to the increased performance of native kivy gui.
Afterwards, a simple GUI was created and the necessary methods are started to get ported over from the old config tool. The seperate dialogues for configuration selection (automatic and manual) were split into their respective screens to streamline navigation.

5.8.
A problem that persisted throughout the prototyping process was the screen for displaying the angles the sensor is reading did not display correctly, mainly with the text label not being displayed. After many itterations, this was fixed by splitting the background and foreground canvas, as well as separating the update mechanics for those. The underlying issue was the clear_canvas() call, which also cleared the label. The reason why it was not rebuild is still partly unknown.
The Angle Display now scales dynamically with the window, giving the user the ability to resize it. 

The logic port of the automatic configuration finished.

Eventually, the table part of the automatic configuration screen was moved to its own class, to be reused with the manual screen.

This was also done with the popup dialogue, which now also accomodates the logic for writing the angles to the database. A small change was made to accomodate custom messages in the initial popup, as the semantics of automatic config confirmation and manual config confirmation change (i.e. just confirm or confirm number of slices).

With these two common elements modularized, the manual config screen was as simple as copying the layout of the automatic config screen, removing the textinput, resizing and relocating the button and changing the logic behind the button press as necessary. Now, with each press of the button, the angle is recorded and shown in the table. When the program detects a similar angle as the first one (i.e. the wheel looped around), the popup dialogue gets called to finish up and commit to database.

6.8.
Ported the kivy file to native python code for the frontend for better visibility with the help of GPT and Claude.
To get moved from the startup screen ("spin wheel") to the topic list screen, a movement detection was necessary. This was promptly implemented into the tlv interface to seperate the logic to where it belongs and make it accessible with a unified API. 
To truly test out the functionality of the frontend and continue the integration, sample data was needed. This was generated using manually collected information from the client's website. Categories were created with the help of AI tools, which the various entries of the data were sorted into. The corresponding importer script was also handled by AI. After a bit of Trial and Error, the function to fetch the necessary data (category, topic titles), based on the current position of the non moving sensor, was finished. Testing this presented the first issue of the buttons not wrapping the text properly, which was then fixed. 

In between all of this, a basic GitHub Project was set up to keep track on the tasks at hand, as well as adding any information for planning/execution to the respective steps.

For a complete workflow, the user would need to be prompted to spin the wheel on startup, which then moves onto a waiting screen to then display the topic list. Whether the user is still browsing topics or reading the description of one, spinning the wheel should always restart this process from the waiting screen. With the current implementation of the movement detection, this was not possible. Thus, the movement detection logic was moved to the parent App class to function as a central controller. The various screens are then able to access the angle read by the sensor via the parent class as well.

7.8.
The content manager application implementation starts. First a draft UI design was made. Following this, the Button Classes from the Frontend were reused in a recylceview of similar construction. For reasons unknown, the buttons did not render correctly. The position of the recycleview itself was correct, but the buttons/recyclelayout were stuck to the bottom left corner. Using database data, the buttons also did not scale correctly. The positioning was fixed by converting the originally Widget class of the ListSelector to be a Recycleview itself. The scaling was fixed by setting an X size hint in the layout and binding the size of the button to the on_size_change function instad of the update_height function. These changes will be backported to the frontend too.
The next, more aethetic issue that arose was the buttons being sorted in alphabetical order instead of numerical order. This was fixed by sorting the input data according to the ID fetched by the database.

Implementing the type selection (categories/topics) proved to be rather difficult. The design requires the user to visually be able to discern, which type was selected at the moment, regardless of the content displayed in the ListSelection. This was eventually achieved using the CompoundSelectionBehaviour and FocusBehavior Class. The necessary method for adding widgets was overwritten and the required events were listened to (button_touch_down, select_node, deselect_node and on_selected_nodes). Communicating the selection then also required certain workarounds to keep a modular and decoupled architecture. In the end, the update of the ListSelection is triggered by a method in the parent ContentManager class, which is called from the MenuBar class via the self.parent statement. MenuBar incorporated parts from a kivy docs example to enable toggleable buttons to visually show which type is selected.


8.8
Continuing with the content manager app, the "editing block" was added, which is supposed to contain the text input fields, as well as the selection to the categories a topic can belong to. Originally, this should've also contained an area for file drag-n-drop but so far it seems like kivy only supports dnd for an entire window, not just certain areas. This will be revised in a future itteration.
For now, the focus lies on the category selector. For this, a numeric property was added to the buttons, which gets the ID from the database object it is supposed to represent assigned. This also (hopefully) lays the groundwork for saving/editing things.
The category selector itself was implemented using a simple scrollview in combination with a stacklayout to enable dynamic scaling of the checkbox areas regardless of text size/length. Methods to load content according to the IDs previously assigned to each button were implemented, as well as a centralized current_data type in the ContentManager parent class. Here, the actual item content loading is triggered from the buttons themselves by getting the content manager from the root window children and calling that function with the ID assigned to the button.
To make things easier, the checkboxes received their own class to combine them with labels. These got, among other, a property for category id, which will be assigned on generation. This enables simple cross-checking with the database, whether a topic belongs to a category, making it simple to already mark it as checked/active. For categories, only the title is loaded as they do not have any other content. Originally it was planned to have a simpler UI for just category editing, but this idea was quickly abandoned due to integration constraints.

9.8.

The ability to save edits made to topics was added with a "save" button. This button first just updated the entries with the title and description in their respective input boxes based on the ID that is assigned in the properties. Here, the issue of escaping single quotes arose, which highlighted a fundamental flaw in the database design and implementation: SQL Injections. Now that users have the ability to enter any text they would like, SQL Injections now become possible. This would require extensive research on how to escape these characters, as well as a monumental effort to implement those checks. For now, the single quotes are properly escaped by replacing them with double single quotes, but in the future, either the queries would need to be checked and escaped properly in the created interface layer, or the architecture would need to shift towards a different library that already accomplishes this.

To edit each topics assignment to categories, the state of the checkboxes is fetched and if checked, appended to a list along with the ID. This approach makes it easier to later feed it into the execute_many statement, as the data is already prepared accordingly. Updating the table is done simply by removing all entries to this topic ID and recreating them with the list previously created. 

The only thing that was missing for this tool at this point was the ability to create and remove topics. This specifically only includes topics, as the current infrastructure would not allow adding and removing topics comprehensively. Categories are connected to the slices of the spinning wheel. Adding or removing a slice would most likely require all slices to be resized, requiring the user to redo the initial configuration. Thus, categories will neither be removable or addable by this tool.
Buttons were added to the MenuBar for adding and removing items. These buttons call their own methods, which call methods from the content Manager parent. For adding things, a generic filler topic is created, which then can be edited. For removing topics, the selected ID is fetched from the editing_block and promptly removed from the database. Because those two buttons were tied into the MenuBar, which had a lot of custom SelectionBehaviour, certain things needed be adjusted. First, when pressing a button, the selected nodes would be processed. This was undesirable for the add and remove buttons. To mitigate this, the on_selected_nodes function was edited to remove all nodes that were not "Categories" or "Topics". Here, the super function of deselection had to be called, as the color change used in the custom function would not work well here. Additionally, a text color change was added on selection for all buttons of the Menu bar, improving readability.

12.8.

A few workflow and aesthetic errors were fixed. With the previous implementation, pressing the add or remove buttons deselected the Topic or Category buttons. This was fixed by isolating the Type selector to its own class and adding it back to a MenuBar as previously. Only now, the selection logic is isolated with the type selectors only. This also improves usability of the add/remove buttons, as they are no longer bound by logic that is undesirable for them. The respective methods were adjusted accordingly.

When adding a new topic, previously the topic was just added, required a refresh of the list (by toggling the type) and manually scrolling down. This is now automated. Adding a topic now updates the list and scrolls down to the bottom of the list automatically. Removing a topic also automatically updates the list so the removal is immediately visible.

The database scheme was editied slightly. While it seemed to make sense at first to call the table that stores all data of the physical slices of the wheel "slices", during development this was mostly interpreted as "categories". Thus, the name was changed to categories to streamline things going forward, and the respective queries were adjusted.

At this point, it was clear that the current architecture was failing. The UI elements contained an stiffling amount of logic and were too intertwined to be considered comprehensive. This happened due to missing knowledge of the UI framework and just adding on top of existing code instead of rethinking the logic and refactoring smaller parts as needed, causing a large amount of technical debt to accumulate. Proceeding with things the way they were was deemed to be too costly in terms of development effort and maintainability. Thus, a refactoring effort was started. This first began by comprehensively sorting different modules. The module for the sensor was moved into a "Hardware" directory, the database manager and database itself into a "database" directory. Following this, a plan was created to move all logic and UI-DB communications into service layers. 
Data classes for Topic and Categories were created to expose the DB data in a processable manner. The Category service class was created and first methods were implemented. This also required adjustment in the database manager to enable placeholder processing for the simple execute query, which also mitigated the risk of SQL injections as the base sqlite module now handles the query creation entirely. While the risk of SQL Injections is now mitigated, the issue of overwriting the data with NoneType data was discovered. By adding an extra check for the contents of the parameters, this was also temporarily mitigated. Queries with parameters that contain NoneTypes will now be executed without parameters, which will throw an error that still reqires appropriate error handling. With every function implemented, basic tests were conducted to examine program behavior. If the program behaved as intended, the next function was implemented.
After every function has been verified, the related functions in the content manager app were replaced accordingly. No issues arose from this step.
Continueing with the refactorization, both button classes and the labeled checkbox class were isolated in their own package to import where they are needed. This accomplishes the goal of unified UI design, as the buttons are used both in the application and the content manager. To simplify things, the on_press function for the content manager was implemented as a subclass override in the CM itself. This means that the application is not influenced by CM logic and vice versa. Lastly, proper Constructor injection was set up for all classes that required certain communications with higher tier objects. For example, the TypeSelector requires calling a centralized function in the higher tier content manager window. To facilitate this, both MenuBar (the parent class of TypeSelector) and TypeSelector received the content manager window as a constructor parameter object to communicate to. This also helped with the MenuBar, as the Add/remove_items function required the call to the CM too.

Refactoring the UI proved to be smaller in complexity, as there is less logic to port over. The database calls that were there were replaced with the corresponding calls for the service classes. The Buttons were replaced with imports to the unified ones. The biggest challenge seemed to be fetching the details when a button is pressed. Previously, this was done with a direct database access inside the button, which is not viable with the new architecture. Ultimately, the button subclass (similar to CM) got two additional properties along with the on_press override: topic_id (Numerical) and on_choose(Object). the on_choose property stores a callback to a TopicListScreen function that handles all the logic. Meaning, the button does nothing more than storing the topicID and the callback adress it's supposed to call when pressed. This makes changing the logic simpler as it lives outside the button. Moving the logic had another benefit: the screen manager to change screens was readily accessible, as it was a direct property of TopicListScreen due to it being a Screen class.
At last, the tlv parameter of the TopicListScreen was replaced with the simple angle. The idea behind this is that once the screen stopped moving, there is no need to read the angle again. If the wheel spins significantly, the Page will get reloaded anyways. This also helps protect against edge cases where the wheel moves so slowly that it stays below the threshold and eventually moves to a different category. Reloading topics for that category while still browsing the old one is undesirable.


17.8.
Refactoring the codebase did not go without it's issues. There were severe UI update loops in the frontend application. While they did not seem to impact performance nor reliability, it was worthwhile fixing them. The loops were ultimately caused by the hoverableButtons size change, which conflicted with size change loops in the frontend. This was fixed by adjusting the buttons to only adjust the text size if the width changes, as well as adding a flag to prevent recursive calls.
Other adjustments were made that went under the radar due to lack of testing. The TLV sensor first filled up the moving average in the first second or two, requiring some delay. Filling the array with the first reading mitigated this. The topicListScreen was assigned an attribute for the angle, which is overwritten before changing screens. This fixes a previous implementation, where the screen got it's angle assigned on startup, which promptly did not change afterwards due to it being already assigned (Highlighting how i'm still learning how kivy works). Lastly, the sql query for getting categories by angles was adjusted to support angle wrapping. This previously caused issues with categories, that started at a "high" angle and ended at a "low" angle (meaning it went over 0/360), resulting in either crashes or empty lists as no category was fetched.

Implementing the Search bar functionality required the TopicListScreen to be remade as a FloatLayout, as the first idea was to put the searchbar next to the title, which is not something the old boxlayout implementation would have supported. However, it was decided to put the searchbar below the title later on. This also required some resizing of the recycleview, which was achieved using the usualy pos_- and size_hints. It is important to note that both should be applied on the recycleview itself, not it's layout. The searchbar was then created using a simple TextInput field, with a function binding for the "on_text_validate" event. As there was no direct way to search for topics using keywords, a "search" method was implemented in the TopicService to facilitate this. To expand the TopicService's functionality further, the search function only returns a list of IDs, for which a "get_many" function was created to return a list of Topics for a list of IDs. This way, each functionality is more broadly usable while keeping the overhead low (just two function calls). A problem that was encountered in implementing the get_many function was sqlite3's inability to use Lists as data. Executemany only supports DML (Data manipulation language, i.e. INSERT,DELETE, etc), execute only supports non-iterative data types natively. After some research on this topic, it seems that the most popular approach was to chain as many placeholders together as there are entries in the list, most likely to make use of the injection mitigation enabled by placeholders.
The next problem that arose was how to communicate the on_enter event of the searchbar to the recycleview and create buttons only based on the topics that contain the key word. The following decisions were made to facilitate this while improving modularity: 
1. move rv data updates to its own function
2. pass the parent topiclistscreen to the searchbar 
3. keep the logic in the topiclistscreen (tls), only make searchbar call tls function with the text input
This created the function "on_search", which uses both topicservice search and get_many functions to then pass a list of topics to the update_buttons function. The on_enter function also just passes it's list of topics to this function.

At this point in time it was discovered that kivy supports custom events and -handlers. However, it was deemed to time intensive to rewrite all inter-widget communications to use this. Thus, this idea was abandoned, but still worthy enough to mention if there is continued interest to develop this in the future. Using custom events might enable more ways of communication between widgets.

Another feature that was deemed as required for a viable product was to name the categories directly in the configuration tool. First, the simple generated label was replaced with a text input with it's background removed and a function attached to it's on_text_validate event. Here, the question arose on how to actually overwrite the data once the name has been edited. Eventually it was decided that a custom textinput class had to be made which contained a unique identifier, here the angle as there can't be two categories assigned to the same beginning angle. Additionally, the list was replaced with a dict with the angle as the key and name as the value to make lookup easier. The actual storage of the data was also moved to the TableDisplay class alone as having it shared among all classes seemed to cause more issues than benefits. This also led to the decision to only update the table with new values instead of replacing it's entire data each update call, as previously. 
A function to clear the table and get it's length were added too, one to replace the previous implementation of the "back" button, the other for default name generation. 
Finally, all other functions were adjusted to use this improved functionality.
While this was all underway, the AngleDisplay was noticed to have it's rotation reversed. This seemed to be a simple mathematical issue that was solved with negating the Y component of the atan2. However, the AngleDisplay coordinate system also appeared to require some adjustments after that. First, the negation of the label was removed as it was not necessary anymore. The actual AngleDisplay still needed the negation though, to match the rotation direction of the sensor. This might be due to Kivy's different interpretation in the coordinate system.



Here, a discussion about adjusting the scope would need to be had. While software development progresses consistently, it has been noted that other parts of this thesis, namely the physical development and "paperwork"(schreibarbeit) have not progressed significantly, if at all. Since the time and development effort certain features require can be estimated in advance to some extend, it became evidante that the available resources would not suffice to realize all planned features. Consequently, a priorization is necessary to ensure a timely completition. The following features are proposed to be omitted, in this order of "priority":
1. LED Signs: While the construction of those would be reasonably fast, there are features that have a higher priority that require more time.
2. NFC Card reader: While the time required for implementation could potentially be estimated, it might not be feasable within the available timeframe. Additionally, 	it is unknown how many users actually own an NFC enabled business card.
3. Guest book camera integration: At this point in time, it is not clear how much time this would require to implement due to unknown software support. 
4. Feedback Mechanism: The additional development of a webpage is not feasable within the available timeframe or scope of knowledge.
5. Multimedia Support: This is dependent on other features that have been prioritized as some parts of it's implementation are already created and in place. Nonetheless, the time required to finish it's implementation might be too much.

Features that will be prioritized:
1. Controller support: It was already purchased and is a key element in the user interaction. Implementing software support will require a sizable amount of time due to potential rewrites that can become necessary, especially considering the required FocusBehavior.
2. Guestbook: To offer the very basics of this feature for future expansion, an additional workflow needs to be implemented into the current frontend application.
3. Physical construction of the product: The physical manifestation of this project takes priority over more elaborate features. While it might not take as much time as other parts, it is arguably the most important aspect in this project.


Currently, the project is at the point of a minimum viable product. The fundamental features are working and have their required tools. Users can configure the spinning wheel, record angles and name the corresponding slices. Blank topics can be added, filled with necessary information and assigned to categories. Topics can also be removed and reassigned. In the main application, categories can be chosen using the spinning wheel, topics can be explored for every category they're assigned to and expanded to obtain more details.


21.8.

It was decided to make the configuration tool a more comprehensive tool to use by giving it the ability to delete/create topics as well as reassign angles.
These methods were implemented in the categoryService.

(its late and i want to finish this asap)
First angle assignment:
- Goal: Overwrite the angles of a given category
- Problem: What happens if angles overlap. How to handle?
- resolution: provide flag for overflow handling. If false, just set angles and be done. If true, get adjacent categories (next & prev) and adjust their beginning and end angle to end and beginning angle of the adjusted one. Call method again with same values and disable overflow flag to just set it.

create category:
- Goal: create a category and assign angles to it
- Problem: What happens if a same named category exists? Violates unique constraint for category title!
- Resolution: Check if same title category exists, if yes just change angle
If no, create new category with title and 0,0 angles, commit changes, select again to get ID and use assign angles function to assign actual angles to manage overflow.

delete category:
- Goal: delete a category
- Problem: what happens with the empty space?
- Resolution: Provide leave_empty flag to decide whether or not to fill the hole. if True, just delete nothing else. If false, calculate the distance the old category had from begin to end angle and divide by two. Get adjacent angles and use assign angles function to assign new angles. Next category begins "earlier", prev category ends "later".

Topic and Category classes were also expanded with their string representations for easier debugging. This enables printing the object and receiving a string instead of an object.

CategoryService was also expanded with functions to get categories with similar titles and a category with the exact same title. These functions were implemented because there appeared a need for them, but they ended up unused in all of the other three functions above due to accuracy issues (e.g. create category needed a query to look for a title and set angles, not just title).

Testing the newly implemented functions output an error that, even after extensive investigation, still seemed to be paradoxical.
"Query execution failed due to: Incorrect number of bindings supplied. The current statement uses 3, and there are 0 supplied."
This specifically came from the "UPDATE" query in assign angles function. However, this function was identical to the one in the topicService (apart from column/variable names), so how come the topicservice query works but this doesn't?
After a long time of tracing down this error, it was discovered to originate from the safeguard implementation of the DB execute statement. Specifically, the all() in "if params and all(params)". It was discovered that all() is false when given a 0, an empty string and a False boolean. This was not desired, as it was only used to check for nested None types. This was then replaced with a dedicated None type check: "if all(p is not None for p in params)"


After solving this, testing the assign angles function as well as create category function went with only minor issues.
However, deleting a category proved to be difficult due to various query issues. If only one query returned None, the entire process would throw an error. Eventually, the issue was traced down to the "get_for_angle" function, which had no failsafe in case the query didn't result in anything. Thus a simple Nonecheck was added.

23.8.

The configuration tool was adjusted to use the category service, especially the create_category function. 
Where previously, it was planned to expand the configuration tool with comprehensive category management (i.e. Deleting, creating, manually adjusting angles), It was decided to not expand the configuration tool any further at this point in time and rather focus on implementing the Controller support. 
This decision was made based on the educated assumption, that the most commmon change of categories would be renaming them, which is already featured in the content manager (Renaming can also be seen as a replacement function). The other possibilities left are adding more categories or removing them, and while those are made possible in the category service, integrating them in the configuration tool would require an extensive overhaul of it's layout and workflow. However, for the sake of maximizing data integrity, reconfiguring all categories from the beginning has been assigned as the default workflow in those cases.

The only improvement that will be made to the config tool at this point is overwriting categories with existing titles while removing and replacing others.
For this, the angles_to_database function was adjusted to test if any of the provided titles are already within the database. Testing this, an error was encountered of the element not being inside the list, despite print statements clearly showing the contrary. This was caused due to the custom Category class not having a compare operation, which was promptly added. For now, the compare operator will just compare by id, though it might be useful to also add the title in that equiation. This will be adjusted as necessary. A hash function was also added on recommendation of Claude, in case Category objects are used in sets/dicts. Basic testing of this feature showed no problems with it's current implementation, thus it was marked as complete.

Lastly, joystick communications were confirmed by installing the recommended packages for joystick support (joystick lol) and choosing an appropriate python library. Here, evdev was chosen for the following reasons:

- it talking directly to the kernel level interface /dev/input/event for full control
- broad hardware support as it works with any device under /dev/input
- lightweight as it only focuses on input

A simple testing script was generated using GPT to bind the controller and print the outputs. This resulted in various kinds of outputs that were insightful on how this controller functions.
It was discovered that the controller returns a code and value (among other things) for each event triggered. Decoding these resulted in a clear mapping for each button and stick movement, which was promptly and successfully tested and confirmed to hold true.

Planing on how the controller wrapper is supposed to work and communicate it's inputs to other classes, the following decisions were made:
1. The wrapper manages it's own thread for simplicity
2. Inputs will be put in a queue for the ExplorerApp to work through
3. To clearly communicate and define each input, an Enum class was necessary to define each kind of input.
4. Inputs will only be triggered on the "button down" event, not the up

Additionally to the 5 pre defined LEFT, RIGHT, UP, DOWN, SELECT Enums, a NOTHING enum was added. With only the "button down" event triggering an input, holding down a button or the stick to scroll is not possible. This nothing enum could be used to facilitate this, by moving down until the NOTHING input was triggered. However, this is a feature for a later point in time.


24.8.
Continueing with the Joystick implementation, the target was set on enabling joystick navigation in the ExplorerApp.
This was first done using the same approach as the TLV, by initializing the Joystick object in the App class, and giving it to each subclass that needs it.
Event handling was done using two functions: one to detect whether the current screen is active and if there has been an input, which then triggers the second class that actually handles the input. This was simply done by checking what intent was in the queue and setting the selection index accordingly.
Problems that arose:
1. The children of the RecycleLayoutBox are not generated IMMEDIATELY after setting the data. It takes some time, which caused some confusion during debugging.
2. Select needed a check whether or not the selection index is between 0 and the max number of items DISPLAYED, it was able to still go beyond that despite setting a min and max in the other two intents, which were the only ones to modify the selectionindex.

Highlighting the selected button was done via indexing all visible buttons and setting the hovered property based on whether the button's index matched the current selection index.
However, in some edge cases it might be possible for a button to be indexed but not rendered (or only by a very small amount). This causes the selection to go "off screen". This appears to be not easily fixable as there currently is no way to determine, which button is actually visible.

The detection and handling methods were ported to both the detail screen and the startup screen. The former was modified to highlight the "back" button automatically if there is a joystick present and trigger it on SELECT input. The latter uses it to skip spinning the wheel and load directly into the category the wheel is at.

Each of these three classes handles their own scheduling regarding input checking. This was done by starting the scheduling in the functions that load the screens, unscheduling was done in functions that load the next screens. This ensures that there will be no race conditions, misinputs or anything along those lines as only one input checking is active at all times.

Implementing auto scrolling once the bottom of the list has been reached proved to be rather difficult with the current way of detecting the selected topic. Scrolling up or down a set amount once at the top or bottom of the shown list is not a problem. However, the RecycleView handles the Buttons similar to a queue, with the object loaded first having the lowest index, while the items loaded last have the highest index. This works when scrolling down, as new items loaded will be at the bottom of the queue, this have the last index. Though, scrolling up again seems to be problematic, as the newly loaded items are appended to the bottom of the queue, even though they should be at the top of it (as they are above the lowest indexed ones).
This problem seemed to require each button to have it's own set index, based on the amount of topics available, not buttons visible. Thus, a NumericProperty was assigned to the AppSelectableButton class. Luckily, kivy has a refresh_view_attrs function, which is called on by the RecycleView (more specifically the RecycleAdapter), when the view is initially populated with the values form the data dict. This function also has an index parameter, which is promptly hijacked and assigned to the index property. Printing all buttons visible with their indizes shows that the indizes are assigned properly. The selection_index was changed to be capped by the amount of data inside the recycleview, not the buttons visible, enabling it to go through all topics in the dict.

This fixed the initial issue of which button to adress/highlight, as this is now done as desired.

Nonetheless, the automatic scrolling still seemed to require some work, as it is not fast enough to keep up with new buttons popping up. Because of this, the selection once again goes off screen.
After contemplating on how to approach this, it seemed to be most sensible to first scroll down a small bit to load the next button, get it's y size and scroll down again by this size. This required a combination of the old and new scrolling methods, as this is dependend on the new buttons loading in. A function was created to get the next button's height and return it as a value. However, it was apparent that this needed to be normalized to the window size or similar, as the scroll_y of the recycleview is a percentage, while the button height is an absolute value.

i am loosing my shit please help. the maths aint mathin

After help from Claude, a somewhat functional scrolling function was created. However, there is some jumping around and faulty highlighting, which only appears the first time of scrolling through the list. After reaching the bottom once, this issue does not appear anymore. Might need to look into caching all recycleview buttons before showing them.
